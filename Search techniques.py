# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JDwFDRyniVwCuOdNfUJWoC4vNgT_oa0E
"""

#bfs
from collections import deque

def bfs(graph, start):
    queue = deque([start])
    visited = set()

    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node)
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

bfs(graph, 'A')

#dfs
def dfs(graph, node, visited=None):
    if visited is None:
        visited = set()
    visited.add(node)
    print(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

dfs(graph, 'A')

#iddfs
def dls(node, target, depth, graph, visited):

    if depth == 0:
        return node == target

    if depth > 0:
        visited.add(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                if dls(neighbor, target, depth - 1, graph, visited):
                    return True
        visited.remove(node)

    return False

def ids(start, target, max_depth, graph):

    for depth in range(max_depth + 1):
        visited = set()
        if dls(start, target, depth, graph, visited):
            return True
    return False

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

start_node = 'A'
target_node = 'F'
max_depth = 3

if ids(start_node, target_node, max_depth, graph):
    print(f"Target node {target_node} is reachable from start node {start_node} within depth {max_depth}.")
else:
    print(f"Target node {target_node} is not reachable from start node {start_node} within depth {max_depth}.")

#least cost search
import heapq

def least_cost_search(graph, start, target):

    priority_queue = [(0, start)]

    costs = {start: 0}

    while priority_queue:

        current_cost, current_node = heapq.heappop(priority_queue)
        if current_node == target:
            return current_cost

        for neighbor, cost in graph.get(current_node, []):
            new_cost = current_cost + cost

            if neighbor not in costs or new_cost < costs[neighbor]:
                costs[neighbor] = new_cost
                heapq.heappush(priority_queue, (new_cost, neighbor))
    return float('inf')

# Example usage:
graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('D', 2), ('E', 5)],
    'C': [('A', 4), ('F', 3)],
    'D': [('B', 2)],
    'E': [('B', 5), ('F', 1)],
    'F': [('C', 3), ('E', 1)]
}

start_node = 'A'
target_node = 'F'
cost = least_cost_search(graph, start_node, target_node)

if cost != float('inf'):
    print(f"The least cost to reach {target_node} from {start_node} is {cost}.")
else:
    print(f"{target_node} is not reachable from {start_node}.")

#best first search
import heapq

def best_first_search(graph, start, target, heuristic):
    priority_queue = [(heuristic[start], start, [start])]
    visited = set()

    while priority_queue:
        _, current_node, path = heapq.heappop(priority_queue)

        if current_node == target:
            return path

        if current_node not in visited:
            visited.add(current_node)
            for neighbor, cost in graph.get(current_node, []):
                if neighbor not in visited:
                    new_path = path + [neighbor]
                    heapq.heappush(priority_queue, (heuristic[neighbor], neighbor, new_path))

    return []

# Example usage:
graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('D', 2), ('E', 5)],
    'C': [('A', 4), ('F', 3)],
    'D': [('B', 2)],
    'E': [('B', 5), ('F', 1)],
    'F': [('C', 3), ('E', 1)]
}

heuristic = {
    'A': 6,
    'B': 4,
    'C': 4,
    'D': 7,
    'E': 2,
    'F': 0
}

start_node = 'A'
target_node = 'F'
path = best_first_search(graph, start_node, target_node, heuristic)

if path:
    print(f"Path found: {' -> '.join(path)}")
else:
    print(f"No path found from {start_node} to {target_node}.")

#A*
import heapq

def a_star(graph, start, target, heuristic):
    priority_queue = [(0 + heuristic[start], 0, start, [start])]

    cost_so_far = {start: 0}

    while priority_queue:

        _, current_cost, current_node, path = heapq.heappop(priority_queue)


        if current_node == target:
            return current_cost, path
        for neighbor, move_cost in graph.get(current_node, []):
            new_cost = current_cost + move_cost

            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost + heuristic[neighbor]
                heapq.heappush(priority_queue, (priority, new_cost, neighbor, path + [neighbor]))

    return float('inf'), []

# Example usage:
graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('D', 2), ('E', 5)],
    'C': [('A', 4), ('F', 3)],
    'D': [('B', 2)],
    'E': [('B', 5), ('F', 1)],
    'F': [('C', 3), ('E', 1)]
}

heuristic = {
    'A': 6,
    'B': 4,
    'C': 4,
    'D': 7,
    'E': 2,
    'F': 0
}

start_node = 'A'
target_node = 'F'
cost, path = a_star(graph, start_node, target_node, heuristic)

if path:
    print(f"Path found: {' -> '.join(path)} with total cost {cost}")
else:
    print(f"No path found from {start_node} to {target_node}.")

#alpha-beta
def alpha_beta(node, depth, alpha, beta, maximizing_player):

    if depth == 0 or is_terminal(node):
        return evaluate(node)

    if maximizing_player:
        max_eval = float('-inf')
        for child in get_children(node):
            eval = alpha_beta(child, depth - 1, alpha, beta, False)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for child in get_children(node):
            eval = alpha_beta(child, depth - 1, alpha, beta, True)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break
        return min_eval

def is_terminal(node):
    return node.is_terminal()

def evaluate(node):
    return node.evaluate()

def get_children(node):

    return node.get_children()

# Example usage:
class GameNode:
    def __init__(self, value, children=None):
        self.value = value
        self.children = children or []

    def is_terminal(self):
        return len(self.children) == 0

    def evaluate(self):
        return self.value

    def get_children(self):
        return self.children

root = GameNode(0, [
    GameNode(0, [
        GameNode(3),
        GameNode(5),
        GameNode(6)
    ]),
    GameNode(0, [
        GameNode(2),
        GameNode(9)
    ])
])

best_value = alpha_beta(root, depth=2, alpha=float('-inf'), beta=float('inf'), maximizing_player=True)
print(f"The best value is: {best_value}")

#min-max
def minimax(node, depth, maximizing_player):

    if depth == 0 or is_terminal(node):
        return evaluate(node)

    if maximizing_player:
        max_eval = float('-inf')
        for child in get_children(node):
            eval = minimax(child, depth - 1, False)
            max_eval = max(max_eval, eval)
        return max_eval
    else:
        min_eval = float('inf')
        for child in get_children(node):
            eval = minimax(child, depth - 1, True)
            min_eval = min(min_eval, eval)
        return min_eval

def is_terminal(node):
    return node.is_terminal()

def evaluate(node):

    return node.evaluate()

def get_children(node):
    return node.get_children()

# Example usage:
class GameNode:
    def __init__(self, value, children=None):
        self.value = value
        self.children = children or []

    def is_terminal(self):
        return len(self.children) == 0

    def evaluate(self):
        return self.value

    def get_children(self):
        return self.children

root = GameNode(0, [
    GameNode(0, [
        GameNode(3),
        GameNode(5),
        GameNode(6)
    ]),
    GameNode(0, [
        GameNode(2),
        GameNode(9)
    ])
])

best_value = minimax(root, depth=2, maximizing_player=True)
print(f"The best value is: {best_value}")